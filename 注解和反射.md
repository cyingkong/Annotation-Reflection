# 1、注解

## 元注解

作用：负责注解其他注解

- **@Target**：用于描述注解的使用范围（即：被描述的注解可以用在什么地方）
- **@Retention**：表示需要在什么级别保存该注释信息，用于描述注解的生命周期
  - （SOURCE < CLASS < **RUNTIME**）
- @Documented：说明该注解将被包含在javadoc中
- @Inherited：说明子类可以**继承**父类中的该注解



# 2、反射

## 2.1、反射概述

Reflection（反射）是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。

```java
Class c = Class.forName("java.lang.String")
```



正常方式：引入需要的“包类”名称 ----> 通过new实例化 ----> 取得实例化对象

反射方式：实例化对象 ----> getClass()方法 ----> 得到完整的“包类”名称



优点：可以实现动态创建对象和编译，体现出很大的灵活性

缺点：对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作。



java.lang.Class : 代表一个类

java.lang.reflect.Method : 代表类的方法

java.lang.reflect.Field : 代表类的成员变量

java.lang.reflect.Constructor : 代表类的构造器



在Object类中定义了以下的方法，此方法将被所有子类继承

public final Class getClass()



以上的方法返回值的类型是一个Class类，此类是Java反射的源头，实际上所谓反射从程序运行结果来看也很好理解，即：可以通过对象反射求出类的名称。

![image-20211201174605053](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211201174605053.png)



## 2.2、得到class类的几种方式：

```java
public static void main(String[] args) throws ClassNotFoundException {
    Person person = new Student();
    System.out.println("这个人是:"+person.name);

    //方式一：通过对象获得
    Class c1 = person.getClass();
    System.out.println(c1.hashCode());

    //方式二：forName获得
    Class c2 = Class.forName("com.ma.reflection.Student");
    System.out.println(c2.hashCode());

    //方式三：通过类名.class获得
    Class c3 = Student.class;
    System.out.println(c3.hashCode());

    //方式四：基本内置类型的包装类都有一个Type属性
    Class c4 = Integer.TYPE;
    System.out.println(c4);

    //获得父类类型
    Class c5 = c1.getSuperclass();
    System.out.println(c5);
}
```



```java
//只要元素类型和维度一样，就是同一个Class
int[] a = new int[10];
int[] b = new int[100];
System.out.println(a.getClass().hashCode());
System.out.println(b.getClass().hashCode());
```



## 2.3、什么时候会发生类初始化？

- 类的主动引用（一定会发生类的初始化）
  - 当虚拟机启动，先初始化main方法所在的类
  - new一个类的对象
  - 调用内的静态成员（除了final常量）和静态方法
  - 使用java.lang.reflect包的方法对类进行反射调用
  - 当初始化一个类，如果其父类没有被初始化，则会先初始化它的父类
- 类的被动引用（不会发生类的初始化）
  - 当访问一个静态域时，只有真正声明这个域的类才会被初始化。
  - 通过数组定义类引用，不会触发此类的初始化
  - 引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）



```java
public static void main(String[] args) throws ClassNotFoundException {
    //1.主动引用
    //Son son = new Son();

    //2.反射也会产生主动引用
    //Class.forName("com.ma.reflection.Son");

    //不会产生类的引用方法
    //System.out.println(Son.b);

    //Son[] array = new Son[5];

    System.out.println(Son.M);

}
```



## 2.4、获取类的运行时结构

通过反射获取运行时类的完整结构

Field、Method、Constructor、Superclass、Interface、Annotation



```java
Class c1 = Class.forName("com.ma.reflection.User");
```

- 获得类的名字

  ```java
  System.out.println(c1.getName());   //获得包名 + 类名
  System.out.println(c1.getSimpleName()); //获得类名
  ```

- 获得类的属性

  ```java
  Field[] fields = c1.getFields();    //只能找到public属性
  
  fields = c1.getDeclaredFields();    //找到全部的属性
  for (Field field : fields) {
      System.out.println(field);
  }
  ```

- 获得指定属性的值

  ```java
  Field name = c1.getDeclaredField("name");
  System.out.println(name);
  ```

- 获得类的方法

  ```java
  Method[] methods = c1.getMethods(); //获得本类及其父类的全部public方法
  for (Method method : methods) {
      System.out.println("正常的:"+method);
  }
  
  methods = c1.getDeclaredMethods();  //获得本类的所有方法
  for (Method method : methods) {
      System.out.println("getDeclaredMethods:"+method);
  }
  ```

- 获得指定方法

  ```java
  Method getName = c1.getMethod("getName", null);
  Method setName = c1.getMethod("setName", String.class);
  System.out.println(getName);
  System.out.println(setName);
  ```

- 获得类的构造器

  ```java
  Constructor[] constructors = c1.getConstructors();  //获得public构造器
  for (Constructor constructor : constructors) {
      System.out.println(constructor);
  }
  constructors = c1.getDeclaredConstructors();    //获得本类所有构造器
  for (Constructor constructor : constructors) {
      System.out.println(constructor);
  }
  ```

- 获得指定构造器

  ```java
  Constructor declaredConstructor = c1.getDeclaredConstructor(String.class, int.class, int.class);
  System.out.println("指定："+declaredConstructor);
  ```



## 2.5、有了Class对象，能做什么？

创建类的对象：调用Class对象的newInstance()方法

- 类必须有一个无参构造器
- 类的构造器的访问权限需要足够

```java
//获取class对象
Class c1 = Class.forName("com.ma.reflection.User");

//构造一个对象
User user = (User) c1.newInstance();    //本质上是调用了无参构造器
System.out.println(user);
```



思考：难道没有无参的构造器就不能创建对象了吗？只要在操作的时候明确的调用类中的构造器，并将参数传递进去之后，才可以实例化操作。

步骤：

- 通过Class类的getDeclaredConstructor(Class ... parameterTypes)取得本类的指定形参类型的构造器
- 向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数
- 通过Constructor实例化对象

```java
//通过构造器创建对象
Constructor constructor = c1.getDeclaredConstructor(String.class, int.class, int.class);
User user2 = (User) constructor.newInstance("甘雨", 001, 18);
System.out.println(user2);
```



























































