# 1、注解

## 元注解

作用：负责注解其他注解

- **@Target**：用于描述注解的使用范围（即：被描述的注解可以用在什么地方）
- **@Retention**：表示需要在什么级别保存该注释信息，用于描述注解的生命周期
  - （SOURCE < CLASS < **RUNTIME**）
- @Documented：说明该注解将被包含在javadoc中
- @Inherited：说明子类可以**继承**父类中的该注解



# 2、反射

## 2.1、反射概述

Reflection（反射）是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。

```java
Class c = Class.forName("java.lang.String")
```



正常方式：引入需要的“包类”名称 ----> 通过new实例化 ----> 取得实例化对象

反射方式：实例化对象 ----> getClass()方法 ----> 得到完整的“包类”名称



优点：可以实现动态创建对象和编译，体现出很大的灵活性

缺点：对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作。



java.lang.Class : 代表一个类

java.lang.reflect.Method : 代表类的方法

java.lang.reflect.Field : 代表类的成员变量

java.lang.reflect.Constructor : 代表类的构造器



在Object类中定义了以下的方法，此方法将被所有子类继承

public final Class getClass()



以上的方法返回值的类型是一个Class类，此类是Java反射的源头，实际上所谓反射从程序运行结果来看也很好理解，即：可以通过对象反射求出类的名称。

![image-20211201174605053](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211201174605053.png)



## 2.2、得到class类的几种方式：

```java
public static void main(String[] args) throws ClassNotFoundException {
    Person person = new Student();
    System.out.println("这个人是:"+person.name);

    //方式一：通过对象获得
    Class c1 = person.getClass();
    System.out.println(c1.hashCode());

    //方式二：forName获得
    Class c2 = Class.forName("com.ma.reflection.Student");
    System.out.println(c2.hashCode());

    //方式三：通过类名.class获得
    Class c3 = Student.class;
    System.out.println(c3.hashCode());

    //方式四：基本内置类型的包装类都有一个Type属性
    Class c4 = Integer.TYPE;
    System.out.println(c4);

    //获得父类类型
    Class c5 = c1.getSuperclass();
    System.out.println(c5);
}
```



```java
//只要元素类型和维度一样，就是同一个Class
int[] a = new int[10];
int[] b = new int[100];
System.out.println(a.getClass().hashCode());
System.out.println(b.getClass().hashCode());
```



## 2.3、什么时候会发生类初始化？

- 类的主动引用（一定会发生类的初始化）
  - 当虚拟机启动，先初始化main方法所在的类
  - new一个类的对象
  - 调用内的静态成员（除了final常量）和静态方法
  - 使用java.lang.reflect包的方法对类进行反射调用
  - 当初始化一个类，如果其父类没有被初始化，则会先初始化它的父类
- 类的被动引用（不会发生类的初始化）
  - 当访问一个静态域时，只有真正声明这个域的类才会被初始化。
  - 通过数组定义类引用，不会触发此类的初始化
  - 引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）



```java
public static void main(String[] args) throws ClassNotFoundException {
    //1.主动引用
    //Son son = new Son();

    //2.反射也会产生主动引用
    //Class.forName("com.ma.reflection.Son");

    //不会产生类的引用方法
    //System.out.println(Son.b);

    //Son[] array = new Son[5];

    System.out.println(Son.M);

}
```



## 2.4、类加载器的作用

- 类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。
- 类缓存：标准的JavaSE类加载器可以按照要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些class对象



JVM规范定义了如下类型的类加载器：

- 引导类加载器：用C++编写的，是JVM自带的类加载器，**负责Java平台核心库**，用来装载核心类库，该加载器无法直接获取
- 扩展类加载器：负责jre/lib/ext目录下的jar包或—D java.ext.dirs指定目录下的jar包装入工作库
- 系统类加载器：负责java—classpath或—D java.class.path所指的目录下的类与jar包装入工作，是最常用的加载器

```java
public static void main(String[] args) throws ClassNotFoundException {

    //获取系统类的加载器
    ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
    System.out.println(systemClassLoader);

    //获取系统类加载器的父类加载器-->扩展类加载器
    ClassLoader parent = systemClassLoader.getParent();
    System.out.println(parent);

    //获取扩展类加载器的父类加载器-->根加载器(c/c++)
    ClassLoader parent1 = parent.getParent();
    System.out.println(parent1);
    /*
    sun.misc.Launcher$AppClassLoader@18b4aac2
    sun.misc.Launcher$ExtClassLoader@1b6d3586
    null
     */

    //测试当前类是由哪个加载器加载的
    ClassLoader classLoader = Class.forName("com.ma.reflection.Test07").getClassLoader();
    System.out.println(classLoader);

    //测试JDK内置的类是谁加载的
    classLoader = Class.forName("java.lang.Object").getClassLoader();
    System.out.println(classLoader);
}
```





## 2.5、获取类的运行时结构

通过反射获取运行时类的完整结构

Field、Method、Constructor、Superclass、Interface、Annotation



```java
Class c1 = Class.forName("com.ma.reflection.User");
```

- 获得类的名字

  ```java
  System.out.println(c1.getName());   //获得包名 + 类名
  System.out.println(c1.getSimpleName()); //获得类名
  ```

- 获得类的属性

  ```java
  Field[] fields = c1.getFields();    //只能找到public属性
  
  fields = c1.getDeclaredFields();    //找到全部的属性
  for (Field field : fields) {
      System.out.println(field);
  }
  ```

- 获得指定属性的值

  ```java
  Field name = c1.getDeclaredField("name");
  System.out.println(name);
  ```

- 获得类的方法

  ```java
  Method[] methods = c1.getMethods(); //获得本类及其父类的全部public方法
  for (Method method : methods) {
      System.out.println("正常的:"+method);
  }
  
  methods = c1.getDeclaredMethods();  //获得本类的所有方法
  for (Method method : methods) {
      System.out.println("getDeclaredMethods:"+method);
  }
  ```

- 获得指定方法

  ```java
  Method getName = c1.getMethod("getName", null);
  Method setName = c1.getMethod("setName", String.class);
  System.out.println(getName);
  System.out.println(setName);
  ```

- 获得类的构造器

  ```java
  Constructor[] constructors = c1.getConstructors();  //获得public构造器
  for (Constructor constructor : constructors) {
      System.out.println(constructor);
  }
  constructors = c1.getDeclaredConstructors();    //获得本类所有构造器
  for (Constructor constructor : constructors) {
      System.out.println(constructor);
  }
  ```

- 获得指定构造器

  ```java
  Constructor declaredConstructor = c1.getDeclaredConstructor(String.class, int.class, int.class);
  System.out.println("指定："+declaredConstructor);
  ```



## 2.6、有了Class对象，能做什么？

创建类的对象：调用Class对象的newInstance()方法

- 类必须有一个无参构造器
- 类的构造器的访问权限需要足够

```java
//获取class对象
Class c1 = Class.forName("com.ma.reflection.User");

//构造一个对象
User user = (User) c1.newInstance();    //本质上是调用了无参构造器
System.out.println(user);
```



思考：难道没有无参的构造器就不能创建对象了吗？只要在操作的时候明确的调用类中的构造器，并将参数传递进去之后，才可以实例化操作。

步骤：

- 通过Class类的getDeclaredConstructor(Class ... parameterTypes)取得本类的指定形参类型的构造器
- 向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数
- 通过Constructor实例化对象

```java
//通过构造器创建对象
Constructor constructor = c1.getDeclaredConstructor(String.class, int.class, int.class);
User user2 = (User) constructor.newInstance("甘雨", 001, 18);
System.out.println(user2);
```



调用指定的方法：

通过反射，调用类中的方法，通过Method类完成。

1. 通过Class类的getMethod(String name,Class ... parameterTypes)方法取得一个Method对象，并设置此方法操作时所需要的参数类型。
2. 之后使用Object invoke(Object obj, Object[] args)进行调用，并向方法中传递要设置的obj对象的参数信息。

```java
//通过反射调用普通方法
User user3 = (User) c1.newInstance();
//通过反射获取一个方法
Method setName = c1.getDeclaredMethod("setName", String.class);

//invoke : 激活的意思
//（对象，"方法的值"）
setName.invoke(user3,"甘雨");
System.out.println(user3.getName());
```



**Object invoke(Object obj, Object[] args)**：

- Object对应 原方法的返回值，若原方法无返回值，此时返回null
- 若原方法为静态方法，此时形参Object obj 可为null
- 若原方法形参列表为空，则Object[] args为null
- 若原方法声明为private，则需要在调用此invoke()方法前，显式调用方法对象的setAccessible(true)方法，将可访问private的方法。

```java
//通过反射操作属性
User user4 = (User) c1.newInstance();
Field name = c1.getDeclaredField("name");

//不能直接操作私有属性，我们需要关闭程序的安全检测，属性或者方法的setAccessible(true)
name.setAccessible(true);

name.set(user4,"王小美");
System.out.println(user4.getName());
```



**setAccessible：**

- Method和Field、Constructor对象都有setAccessible()方法。
- setAccessible作用是启动和禁用访问安全检查的开关。
- 参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。
  - 提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true
  - 使得原本无法访问的私有成员也可以访问
- 参数值为false则指示反射的对象应该实施Java语言访问检查



## 2.7、反射操作注解

```java
public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException {
    Class c1 = Class.forName("com.ma.reflection.Student2");

    //通过反射获得注解
    Annotation[] annotations = c1.getAnnotations();
    for (Annotation annotation : annotations) {
        System.out.println(annotation);
    }

    //获得注解的value的值
    TableMa tableMa = (TableMa) c1.getAnnotation(TableMa.class);
    String value = tableMa.value();
    System.out.println(value);

    //获得类指定的注解
    Field f = c1.getDeclaredField("name");
    FieldMa annotation = f.getAnnotation(FieldMa.class);
    System.out.println(annotation.columnName());
    System.out.println(annotation.type());
    System.out.println(annotation.length());
}
```











































